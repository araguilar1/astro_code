
// ReadBinaryEphemWithCovariance()
// Reads a custom binary ephemeris file format that includes Pos/Vel Covariance
// (the format is written out in commments at the bottom of this file)
// 
// Inputs / Outputs (see below)
//
// Dependencies:  
//       None
//
// Assumptions:
//       None
//  

Define Procedure ReadBinaryEphemWithCovariance(	String filename, 	/* Input/       - filename and path to the binary ephemeris file  */
												Spacecraft   sc);	/*      /Output - Spacecraft to be populated with ephemeris data  */
	
	FileInterface fi;
	
	Variable i;
	Variable j;
	Variable cnt;
	Variable num_obj_id;
	Variable seconds;
	Variable nanoseconds;
	Variable number_of_vectors;
	TimeSpan initial_epoch;
	TimeSpan step_size;
	
	Array vector_data;
	Array indices;

	
	StringArray covariance_element_names = {
				  "P_X_X", "P_X_Y", "P_X_Z", "P_X_Vx",  "P_X_Vy",  "P_X_Vz", 
				           "P_Y_Y", "P_Y_Z", "P_Y_Vx",  "P_Y_Vy",  "P_Y_Vz", 
				                    "P_Z_Z", "P_Z_Vx",  "P_Z_Vy",  "P_Z_Vz", 
				                             "P_Vx_Vx", "P_Vx_Vy", "P_Vx_Vz", 
				                                        "P_Vy_Vy", "P_Vy_Vz", 
				                                                   "P_Vz_Vz"};

	EphemerisVector vector;
	
	If (vector.NumberOfColumns == 0);// in case this procedure gets called in a loop
		vector.AddColumns({"X", "Y", "Z", "VX", "VY", "VZ"});
		vector.AddColumns(covariance_element_names);
	End;
	
	If ((sc.Propagator IsType Ephemeris) == 0);
		sc.SetPropagatorType("Ephemeris");
	End;
	
	Alias eph = (sc.Propagator AsType Ephemeris);
	
	eph.ClearEphemeris();
	
	If (eph.FFEphemProperties.ColumnLabels.Count == 7);
		cnt = 0 ;
		For i = 0 to 5;
			For j = i to 5;
				eph.FFEphemProperties.AddColumn(covariance_element_names[cnt], "OD.Covariance.Matrix", i, j);
				cnt++;
			End;
		End;
	End;
	
	fi.Filename = filename;
	fi.ReadMode = 1;
	fi.BinaryMode = 1;
	fi.Open();
	
	fi.GetPosition = 2;
	
	num_obj_id      = fi.Read(4).DecodeAsType("unsigned int");
	sc.SatelliteId  = num_obj_id.Format("%d");
	
	fi.GetPosition = 6;
	
	seconds     = fi.Read(8).DecodeAsType("int64");
	nanoseconds = fi.Read(8).DecodeAsType("int64");
	
	initial_epoch = TimeSpan.FromSecondsAndFractionalSeconds(seconds, nanoseconds/1.0e9);
	
	seconds     = fi.Read(8).DecodeAsType("int64");
	nanoseconds = fi.Read(8).DecodeAsType("int64");
	
	step_size = TimeSpan.FromSecondsAndFractionalSeconds(seconds, nanoseconds/1.0e9);
	
	number_of_vectors = fi.Read(4).DecodeAsType("unsigned int");
	
	vector_data.Dimension = 27;
	indices.FillLinspace(0, 26, 27);
	
	vector.Epoch = initial_epoch;
	
	For i = 0 to number_of_vectors - 1;
		
		For j = 0 to vector_data.Dimension - 1;
			vector_data[j] = fi.Read(8).DecodeAsType("double");
		End;

		vector.SetVariableValues(indices, vector_data);
		
		eph.AddVectorData(vector);
		
		// set up next epoch
		vector.Epoch += step_size;
	End;
	
	fi.Close();
	
	eph.CurrentIndex = 0;
	
EndProcedure;


// WriteBinaryEphemWithCovariance()
// Writes an Ephemeris object to a custom binary format that includes Pos/Vel Covariance
// (the format is written out in commments below the procedure)
// 
// Inputs / Outputs (see below)
//
// Dependencies:  
//       None
//
// Assumptions:
//       None
// 

Define Procedure WriteBinaryEphemWithCovariance(	Ephemeris       eph,	/* Input/       - the populated ephemeris object to be written to file */
													TimeSpan  step_size, 	/* Input/       - the step-size of the data in the ephemeris  */
													String    object_id, 	/* Input/       - Numeric object ID as a String  */
													String     filename);	/* Input/       - filename and path to the binary ephemeris file to be written  */
	
	FileInterface fi;

	Variable i;
	Variable j;
	Variable k;
	Variable num_vecs;
	Variable flag = 0xAAFF;
	Variable seconds;
	Variable nanoseconds;
	Array vector_data;
	Matrix cov_data;
	
	fi.Filename   = filename;
	fi.BinaryMode = 1;
	fi.WriteMode  = 1;
	fi.ReadMode   = 0;
	fi.Open();

	fi.Write(flag.EncodeAsType("unsigned short"));
	fi.Write(object_id.ToVariable().EncodeAsType("unsigned int"));

	seconds     = eph.StartEpoch.GetWholeSeconds();
	nanoseconds = round(eph.StartEpoch.GetFractionalSeconds()*1e9);

	fi.Write(seconds.EncodeAsType("int64"));
	fi.Write(nanoseconds.EncodeAsType("int64"));

	seconds     = step_size.GetWholeSeconds();
	nanoseconds = round(step_size.GetFractionalSeconds()*1e9);

	fi.Write(seconds.EncodeAsType("int64"));
	fi.Write(nanoseconds.EncodeAsType("int64"));	
	
	num_vecs = eph.NumberOfVectors;
	fi.Write(num_vecs.EncodeAsType("unsigned int"));
	
	
	For i = 0 to num_vecs-1;
		
		vector_data = eph.GetVectorData(i);
		cov_data    = eph.GetCovarianceData(i);
		
		If (vector_data.Dimension != 7);
			Diagnostics.ReportErrorMessage(0, "Error writing Position/Velocity data.  Additional data was supplied, and is not supported.");
		End;
		
		// write pos/vel
		For j = 1 to 6;
			fi.Write(vector_data[j].EncodeAsType("double"));
		End;
		
		// write covariance
		For j = 0 to 5;
			For k = j to 5;
				fi.Write(cov_data[j,k].EncodeAsType("double"));
			End;
		End;
	End;

	fi.Close();
	
EndProcedure;

// this is the "documentation" of the binary ephemeris format
//
//   AAFF:                                    short              : 2
//   Catalog Id:                              unsigned int       : 4
//   Start Epoch Seconds (TAI, GSFC MJD):     int64_t            : 8
//   Start Epoch Nanoseconds (TAI, GSFC MJD): int64_t            : 8
//   Step Size Seconds ():                    int64_t            : 8
//   Step Size Nanoseconds ():                int64_t            : 8
//   Number of Vectors:                       unsigned int       : 4
//   [
//   X (km, MJ2000 Earth Equator):            double             : 8  
//   Y (km, MJ2000 Earth Equator):            double             : 8
//   Z (km, MJ2000 Earth Equator):            double             : 8
//   VX (km/s, MJ2000 Earth Equator):         double             : 8
//   VY (km/s, MJ2000 Earth Equator):         double             : 8
//   VZ (km/s, MJ2000 Earth Equator):         double             : 8
//   Pxx (MJ2000 Earth Equator):              double             : 8
//   Pxy (MJ2000 Earth Equator):              double             : 8
//   Pxz (MJ2000 Earth Equator):              double             : 8
//   Pxvx (MJ2000 Earth Equator):             double             : 8
//   Pxvy (MJ2000 Earth Equator):             double             : 8
//   Pxvz (MJ2000 Earth Equator):             double             : 8
//   Pyy (MJ2000 Earth Equator):              double             : 8
//   Pyz (MJ2000 Earth Equator):              double             : 8
//   Pyvx (MJ2000 Earth Equator):             double             : 8
//   Pyvy (MJ2000 Earth Equator):             double             : 8
//   Pyvz (MJ2000 Earth Equator):             double             : 8
//   Pzz (MJ2000 Earth Equator):              double             : 8
//   Pzvx (MJ2000 Earth Equator):             double             : 8
//   Pzvy (MJ2000 Earth Equator):             double             : 8
//   Pzvz (MJ2000 Earth Equator):             double             : 8
//   Pvxvx (MJ2000 Earth Equator):            double             : 8
//   Pvxvy (MJ2000 Earth Equator):            double             : 8
//   Pvxvz (MJ2000 Earth Equator):            double             : 8
//   Pvyvy (MJ2000 Earth Equator):            double             : 8
//   Pvyvz (MJ2000 Earth Equator):            double             : 8
//   Pvzvz (MJ2000 Earth Equator):            double             : 8
//   ]+