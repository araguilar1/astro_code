

// FitCartesianStateToTLE()
// Used a BatchLeastSquares Estimator to compute a Cartesian position/velocity/cd/cr state to best fit a Norad TLE
// minimizing the position residuals
//
// Inputs:
//       - see below
//
// Dependencies:
//     - ConfigureForceModel()
//
// Assumptions:
//     - Assumes the TLE Spacecraft and stateVector Spacecraft propagators have been properly configured for the analysis


Define Procedure FitCartesianStateToTLE(	StringArray      tleData, 	/* Input/       - the 2 (or 3) line TLE to be fit  */
											Spacecraft stateVectorSc, 	/* Input/Output - Spacecraft with numerical integrator with state to be adjusted */
											Array            fmProps,   /* Input/       - an array of the force model parameters { fieldSize, drag, SRP, scMass, scArea } */
											String          fluxFile,	/* Input/       - the path to the flux data file (blank string uses Default)  */
											TimeSpan    propStepSize,	/* Input/       - the step size of the propagator,in seconds  */
											Variable         fitSpan, 	/* Input/       - The duration of time from (hours) the current TLE epoch to use for the fit  */
											Variable      solveForCd, 	/* Input/       - Flag indicating whether or not to solve for Cd in the fit  (0 to turn off)  */
											Variable      solveForCr);	/* Input/       - Flag indicating whether or not to solve for Cr in the fit  (0 to turn off)  */


	Variable i;
	Variable rms;
	Variable weightedRms;
	Variable prevWeightedRms;
	Variable predictedRms;
	Variable percentChange;
	Variable maxIterations;
	Variable convergencePercentage;
	
	Spacecraft tleSc;
	
	PointSolutionObservation psObs;
	BatchLeastSquaresOD batch;
	
	Array stateVector;
	Array numMeasAccepted;
	Array numMeasRejected;
	
	StringArray measTypes;
	
	TimeSpan endEpoch;
	TimeSpan tleEpoch;

	// first configure the TLE spacecraft
	tleSc.SetPropagatorType("Norad");
	tleSc.Propagator.StepSize = propStepSize;
	tleSc.LoadTLE(tleData);
	
	convergencePercentage = 1;
	maxIterations         = 10;
	tleEpoch              = tleSc.Epoch;
	endEpoch              = tleEpoch + TimeSpan.FromHours(fitSpan);



	//configure the state vector spacecraft
	stateVectorSc.SetPropagatorType("Norad");
	stateVectorSc.LoadTLE(tleData);

	stateVectorSc.SetPropagatorType("RK89");
	stateVectorSc.Propagator.StepSize = propStepSize;

	Call ConfigureForceModel(stateVectorSc, fmProps, fluxFile);
	
	
	stateVectorSc.OD.Cartesian.PositionProcessAction  = 1;
	stateVectorSc.OD.Cartesian.VelocityProcessAction  = 1;

	// set up Cd/Cr estimates based on inputs
	stateVectorSc.OD.Cd.ProcessAction = solveForCd;
	stateVectorSc.OD.Cr.ProcessAction = solveForCr;

	
	// add gps receivers if needed, for data simulation/processing
	If (tleSc.GNSSReceivers.Count == 0);
		tleSc.AddGNSSReceiver("rec1");
	End;
	
	If (stateVectorSc.GNSSReceivers.Count == 0);
		stateVectorSc.AddGNSSReceiver("rec1");
	End;



	// configure the batch
	batch.Reset(1, 1);
	batch.SolutionEpochOption = 3;
	batch.SolutionEpoch       = tleEpoch;
	batch.SpanStartEpoch      = tleEpoch;
	batch.SpanEndEpoch        = endEpoch;
	batch.MaxAllowableSigma   = 3;

	batch.AddObjectToProcess(stateVectorSc);


	// generate data and add (copies) to the batch
	WhileStepping tleSc to (tleSc.Epoch == endEpoch);
		
		// set/reset observer data
		psObs.SetObjectBeingObserved(tleSc);
		psObs.SetObserver(tleSc.GNSSReceivers[0]);
		
		psObs.ObservedEpoch = tleSc.Epoch;
		psObs.X.ObservedValue  = tleSc.X;
		psObs.Y.ObservedValue  = tleSc.Y;
		psObs.Z.ObservedValue  = tleSc.Z;
		psObs.VX.ObservedValue = tleSc.VX;
		psObs.VY.ObservedValue = tleSc.VY;
		psObs.VZ.ObservedValue = tleSc.VZ;
		
		
		//set observer data for use in batch
		psObs.SetObjectBeingObserved(stateVectorSc);
		psObs.SetObserver(stateVectorSc.GNSSReceivers[0]);
		
		// now add a copy of the obs to the batch
		batch.AddObservation(psObs);
	End;
		

	// make sure epochs are synched
	stateVectorSc.StepToEpoch(tleEpoch);


	//iterate the batch
	prevWeightedRms = 0;
	percentChange   = 100;
	While (percentChange > convergencePercentage);
		
		If (batch.IterationCount >= maxIterations);
			Diagnostics.ReportErrorMessage(0, "Batch Solution failed to converge before the maximum Iterations count was reached.");
			ExitProcedure;
		End;

		batch.Iterate();

		batch.GetProcessingStatus(measTypes, numMeasAccepted, numMeasRejected);

		// save the outputs
		stateVector = {stateVectorSc.OD.Cartesian.X.Value,  stateVectorSc.OD.Cartesian.Y.Value,  stateVectorSc.OD.Cartesian.Z.Value, 
						stateVectorSc.OD.Cartesian.VX.Value, stateVectorSc.OD.Cartesian.VY.Value, stateVectorSc.OD.Cartesian.VZ.Value,
						stateVectorSc.OD.Cd.Value, stateVectorSc.OD.Cr.Value};

		
		rms = batch.RMS;
		weightedRms = batch.WeightedRMS;
		predictedRms = batch.PredictedRMS;
		If (prevWeightedRms == 0);
			percentChange = 100;
		Else;
			percentChange = 100*(weightedRms - prevWeightedRms)/weightedRms;
		End;
		prevWeightedRms = weightedRms;
		
		//Report weightedRms, numMeasAccepted.Sum(), numMeasRejected.Sum(), stateVectorSc.EpochText, stateVector;
	End;

EndProcedure;
